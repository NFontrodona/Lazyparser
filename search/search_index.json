{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Lazyparser","text":""},{"location":"index.html#description","title":"Description","text":"<p>The lazyparser module automatically generates command line interfaces by just decorating a function in a python file. This module is based on rich_click.</p> <p>The lazyparser was written in <code>python 3.11</code> with the version 1.8.8 of rich_click. It is compatible with <code>python 3.11</code> or higher.</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>The documentation is available on https://nfontrodona.github.io/Lazyparser/. The documentation was created with material for mkdocs. To build the documentation, clone the project repository, and run :</p> <pre><code>mkdocs build\n</code></pre> <p>This will create a folder <code>site</code>. This folder will contain a file named <code>index.html</code>. Double click on it to open the documentation with your web browser.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>To install lazyparser, run :</p> <pre><code>pip install lazyparser\n</code></pre>"},{"location":"documentation.html","title":"Documentation","text":"<p>Lazyparser is a small module that automates the creation of command-line interfaces. For this purpose, it uses rich_click.</p>"},{"location":"documentation.html#basic-usage","title":"Basic usage","text":""},{"location":"documentation.html#without-docstring","title":"Without docstring","text":"<p>Let's say you have a function <code>print_word</code> that prints two words. To create a command line interface, you can simply type this in a file <code>example.py</code></p> <pre><code>import lazyparser as lp\n\n@lp.parse\ndef print_word(a, b):\n    print(a)\n    print(b)\n\nif __name__ == \"__main__\":\n    print_word()\n</code></pre> <p>Then you can display the help of <code>example.py</code> by typing:</p> <pre><code>python example.py --help  # to display the help of your program\n</code></pre> <p>This will print the following message :</p> <pre><code>\n Usage: example.py --b STRING --a STRING\n\n\u256d\u2500 Optional arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help  -h    Show this message and exit.            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Required arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --a  -a  TEXT  param a [required]                 \u2502\n\u2502 *  --b  -b  TEXT  param b [required]                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>If there is no docstring in the decorated <code>print_word</code> function, the type of every parameters is set to <code>str</code>. In addition, the full names of the parser arguments (defined with <code>--</code>) correspond to the parameter names of the decorated function. The short names (called with <code>-</code>) are computed on the fly and correspond to the first letter of the related parameter. For each parameter in the decorated function, a basic help message is auto-generated, though this default message provides minimal information about what each parameter actually does. To customize how the help message will be displayed, you can write a docstring in the decorated function.</p>"},{"location":"documentation.html#with-docstring","title":"With docstring","text":"<p>Lazyparser automates the creation of command-line interfaces by taking advantage of the docstring in the decorated function and the type of the parameters indicated in the function definition. By default, lazyparser parses the docstring in PyCharm (A Python IDE) format.</p> <p>Example: (file <code>example.py</code>)</p> <pre><code>import lazyparser as lp\n\n@lp.parse\ndef multiplication(a: float, b: float):\n    \"\"\"Multiply a by b\n\n    :param a: a number a\n    :param b: a number b\n    \"\"\"\n    print(a * b)\n\n\nif __name__ == \"__main__\":\n    multiplication()\n</code></pre> <p>Then, you can display the help of <code>example.py</code> by typing:</p> <pre><code>$ python example.py -h # to display the help of your program\nUsage: example.py --b FLOAT --a FLOAT\n\nMultiply a by b\n\n\u256d\u2500 Optional arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help  -h    Show this message and exit.            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Required arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --a  -a  FLOAT  a number a [required]             \u2502\n\u2502 *  --b  -b  FLOAT  a number b [required]             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"documentation.html#optional-arguments","title":"Optional arguments","text":"<p>In the previous example, you can see that --a and --b are required arguments. To make an argument optional, you can give it a default value in the function definition. For example, if you want to make the argument --b optional, you can define it as follows:</p> <pre><code># same as above\n@lp.parse\ndef multiplication(a: float, b: float = 5):\n    \"\"\"Multiply a by b\n\n    :param a: a number a\n    :param b: a number b\n    \"\"\"\n    print(a * b)\n# same as above\n</code></pre> <pre><code>$ python example.py --help\nUsage: example.py --a FLOAT [--b FLOAT]\n\nMultiply a by b\n\n\u256d\u2500 Optional arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help  -h         Show this message and exit.       \u2502\n\u2502 --b     -b  FLOAT  a number b [default: 5]           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Required arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --a  -a  FLOAT  a number a [required]             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"documentation.html#standalone-mode","title":"standalone mode","text":"<p>By default the standalone mode is enabled, this means that nothing can be executed after the call of the decorated function, for example this code won't print anything after \"starting\":</p> <pre><code>import lazyparser as lp\n\n@lp.parse\ndef multiplication(a: float, b: float):\n    \"\"\"Multiply a by b\n\n    :param a: a number a\n    :param b: a number b\n    \"\"\"\n    print(\"starting\")\n    return a * b\n\n\nif __name__ == \"__main__\":\n    v = multiplication() # nothing executed after this\n    print(v)\n</code></pre> <pre><code>$ python example.py -a 5 -b 10\nstarting\n</code></pre> <p>To make the code continue, you can disable the click standalone mode by using the <code>sandalone(False)</code> decorator</p> <p>Example:</p> <pre><code>import lazyparser as lp\n\n@lp.standalone(False)\n@lp.parse\ndef multiplication(a: float, b: float):\n    \"\"\"Multiply a by b\n\n    :param a: a number a\n    :param b: a number b\n    \"\"\"\n    print(\"starting\")\n    return a * b\n\n\nif __name__ == \"__main__\":\n    v = multiplication() # noting executed after this\n    print(v)\n</code></pre> <pre><code>$ python example.py -a 5 -b 10\nstarting\n50.0\n</code></pre>"},{"location":"documentation.html#customize-the-docstring-environment","title":"Customize the docstring environment","text":"<p>If you are not a fan of Pycharm docstrings, you can set your own docstring environment by using the decorator <code>docstrings</code></p> <p>the decorator <code>docstrings</code> can takes up to 4 arguments :</p> <ul> <li><code>delim1</code> : the string preceding the definition of a parameter.   :param is the default value. This parameter can be an empty   docstring if nothing precedes the parameter name in the docstring of   the decorated function.</li> <li><code>delim2</code> : the string that comes right after the name of the   parameter. It MUST be defined and can't be an empty string or a   space, tabulation, etc... It's default value is <code>:</code></li> <li><code>header</code> : the header preceding the argument names. By default,   corresponds to an empty string.</li> <li><code>tab</code> : the number of spaces at the beginning of each line in the   docstring. By default, it is equal to 4.</li> </ul> <p>Note</p> <p>the text set before parameters definition (or the parameters definition header) is considered as being a part of the description of the function.</p> <p>Here is an example of how to use <code>docstrings</code></p> <pre><code># code in example.py file\nimport lazyparser as lp\n\n@lp.docstrings(delim1='', delim2=':', header=\"Arguments:\")\n@lp.parse\ndef multiplication(a: float, b: float):\n    \"\"\"\n    Multiply a by b\n\n    Arguments:\n         a : a number a\n         b : a number b\n    \"\"\"\n    print(a * b)\n\nif __name__ == \"__main__\":\n    multiplication()\n</code></pre>"},{"location":"documentation.html#type-of-parameters","title":"Type of parameters","text":"<p>Lazyparser can handle different types of parameters (defined in the function definition):</p> <ul> <li><code>int</code></li> <li><code>float</code></li> <li><code>bool</code></li> <li><code>str</code> : default type if nothing is specified in the function definition.</li> <li><code>tuple</code> : A tuple object used to handle multiple values.</li> </ul> <p><code>tuple</code> type must have at least one subtype defined in the function definition. For example, if we want to define a tuple with one integer, we can set the type <code>tuple[int]</code></p>"},{"location":"documentation.html#example-of-tuple-usage","title":"Example of <code>tuple</code> usage :","text":"<pre><code>import lazyparser as lp\n\n@lp.docstrings(delim1=\"\", delim2=\":\", header=\"Arguments:\")\n@lp.parse\ndef print_value(a: tuple[int]):\n    \"\"\"\n    Display the parameter a\n\n    :param a: The argument a\n    \"\"\"\n    print(f\"a = {a}\")\n\n\nif __name__ == \"__main__\":\n    print_value()\n</code></pre> <p>Defining a tuple with an elipsis as the second type <code>tuple[int, ...]</code> allows you to give as many data as you by repeating <code>-a</code> in the command line interface. Here is an example:</p> <pre><code># same as above\ndef print_value(a: tuple[int, ...]):\n# same as above\n</code></pre> <pre><code>$ python example.py -a 1 -a 2 -a 3 -a 20\na = (1, 2, 3, 20)\n</code></pre>"},{"location":"documentation.html#click-types","title":"Click types","text":"<p>You can use custom click types (see this page instead of the simple ones that you give in the function signature. For example if you want to use the custom type <code>click.IntRange(0, 10)</code>, you can do so in the <code>lazyparser.parse</code> function using the following syntax:</p> <pre><code>@lazyparser.parse(param=click.IntRange(0, 10))\n</code></pre> <p>where <code>param</code> is the name of the parameter you want to use the custom type for.</p> <p>Note</p> <p>the type of param given in the function signature should be <code>int</code> in this case otherwise you will get an warning telling you that the click type will be applied.</p>"},{"location":"documentation.html#example","title":"Example:","text":"<pre><code>import lazyparser as lp\n\n\n@lp.parse(values=lp.click.IntRange(0, 10))\ndef print_value(values : int):\n    \"\"\"\n    Print an input number between 0 and 10\n    \"\"\"\n    print(\"Your number is\", values)\n\nif __name__ == \"__main__\":\n    print_value()\n</code></pre> <pre><code>$ python example.py -v 15\n\nUsage: example.py [OPTIONS]\n\nTry 'example.py --help' for help\n\u256d\u2500 Error \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Invalid value for '--values' / '-v': 15 is not in the range        \u2502\n\u2502 0&lt;=x&lt;=10.                                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n$ python example.py -v 8\nYour number is 8\n</code></pre>"},{"location":"documentation.html#boolean-flag","title":"Boolean flag","text":"<p>Sometimes, you only want to call an argument without giving it a value when calling your program. This applies automatically and only for Booleanvalues</p> <p>Here is an example :</p> <pre><code>import lazyparser as lp\n\n@lp.parse\ndef flag_func(a: bool = False):\n    \"\"\"\n    Give the value of the flag\n\n    :param a: the boolean flag\n    \"\"\"\n    print(f\"value of a: {a}\")\n\n\nif __name__ == \"__main__\":\n    flag_func()\n</code></pre> <pre><code>$ python example.py -a\nvalue of a: True\n$ python example.py\nvalue of a: False\n</code></pre>"},{"location":"documentation.html#create-an-epilog","title":"Create an epilog","text":"<p>To add an epilog in the help of the parser simply use the decorator <code>epilog</code>. This function must be called before the decorator <code>parse</code>.</p> <pre><code>@lp.epilog(\"my epilog\")\n@lp.parse\n...\n</code></pre>"},{"location":"documentation.html#argument-groups","title":"Argument groups","text":"<p>By default, Lazyparser creates two groups of arguments:</p> <ul> <li><code>Optional arguments</code></li> <li><code>Required arguments</code></li> </ul> <p>But, you may want to create argument groups with custom names. This can be done with the decorator <code>groups</code> that takes a group name and a list of options defined in the group. The order of groups given in the groups decorator will be the same as the order of group displayed in the help message.</p> <p>This function must be called before the decorator <code>parse</code>.</p>"},{"location":"documentation.html#example_1","title":"Example","text":"<p>Below, in an file named <code>example.py</code>. You can see a function that prints the name and the first name of a user and also multiply two numbers:</p> <pre><code>import lazyparser as lp\n\n@lp.groups(help=[\"help\"], Numbers=[\"x\", \"y\"], User=[\"first_name\", \"name\"])\n@lp.parse\ndef multiply(first_name: str, name: str, x: float, y: float):\n    \"\"\"Say hello name fist_name and multiply x by y.\n\n    :param first_name: your first name\n    :param name: your name\n    :param x: a number x\n    :param y: a number y\n    \"\"\"\n    print(f\"Hello {first_name} {name} !\")\n    print(f\"{x} x {y} = {x * y}\")\n\n\nif __name__ == \"__main__\":\n    multiply()\n</code></pre> <p>If you run:</p> <pre><code>python example.py -h\n</code></pre> <p>It displays:</p> <pre><code>Usage:\nexample.py\n--y FLOAT --x FLOAT --name TEXT --first_name TEXT\n\nSay hello name fist_name and multiply x by y.\n\n\u256d\u2500 help \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help  -h    Show this message and exit.            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Numbers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --x  -x  FLOAT  a number x [required]             \u2502\n\u2502 *  --y  -y  FLOAT  a number y [required]             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 User \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --first_name  -f  TEXT  your first name           \u2502\n\u2502                            [required]                \u2502\n\u2502 *  --name        -n  TEXT  your name [required]      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n</code></pre>"},{"location":"documentation.html#version-option","title":"Version option","text":"<p>In order to have a option to display the version you can use the <code>version</code> decoartor.</p>"},{"location":"documentation.html#example_2","title":"Example","text":"<pre><code>import lazyparser as lp\n\n@lp.version(\"1.0\")\n@lp.parse\ndef multiplication(a: float, b: float):\n    \"\"\"\n    Multiply a by b\n\n    :param a : a number a\n    :param b : a number b\n    \"\"\"\n    print(a * b)\n\nif __name__ == \"__main__\":\n    multiplication()\n</code></pre> <p>If you run:</p> <pre><code>$ python example.py -h\nUsage: example.py --b FLOAT --a FLOAT\n\nMultiply a by b\n\n\u256d\u2500 Optional arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help     -h    Show this message and exit.         \u2502\n\u2502 --version        Show the version and exit.          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Required arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --a  -a  FLOAT  a number a [required]             \u2502\n\u2502 *  --b  -b  FLOAT  a number b [required]             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n$ python example.py --version\nexample.py, version 1.0\n</code></pre> <p>Warning</p> <p>Your function cannot contain a parameter named <code>version</code> anymore.</p>"},{"location":"documentation.html#using-multiple-decorators","title":"Using multiple decorators","text":"<p>You can use multiple decorators like <code>lp.version</code>, <code>lp.standalone</code>, <code>lp.groups</code> and <code>lp.docstrings</code> in any order with the exception of the <code>lp.parse</code> decorator which should be the first one to decorate your function.</p> <pre><code>import lazyparser as lp\n\n@lp.docstrings(delim1=\"-\", delim2=\":\", header=\"@Args\") # In any order (expect the first)\n@lp.groups(values=[\"a\", \"b\"], Help=[\"help\"]) # In any order (expect the first)\n@lp.version(\"1.0\") # In any order (expect the first)\n@lp.standalone(True) # In any order (expect the first)\n@lp.parse # must be the first decorator\ndef multiplication(a: float, b: float):\n    \"\"\"\n    Multiply a by b\n\n    @Args\n    - a : a number a\n    - b : a number b\n    \"\"\"\n    print(a * b)\n\nif __name__ == \"__main__\":\n    multiplication()\n</code></pre>"},{"location":"reference.html","title":"Reference","text":"<p>Author : Fontrodona Nicolas (2019)</p> <p>Copyright 2019 Fontrodona Nicolas</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p>This script define the lazyparser.</p>"},{"location":"reference.html#lazyparser.Argument","title":"<code>Argument</code>","text":"<p>               Bases: <code>object</code></p> <p>Represent a Lazyparser Argument.</p> Source code in <code>lazyparser.py</code> <pre><code>class Argument(object):\n    \"\"\"\n    Represent a Lazyparser Argument.\n    \"\"\"\n\n    def __init__(self, name_arg, default, arg_type):\n        \"\"\"\n        Initiate the creation of an argument.\n\n        :param name_arg: (string) the name of the argument\n        :param default: the default value of the argument\n        :param arg_type: (type) the type of the argument\n        \"\"\"\n        self.name = name_arg\n        self.default = default\n        self.help = \"param %s\" % self.name\n        self.short_name: str | None = None\n        self.value = None\n        self.is_flag = False\n        self.const = \"$$void$$\"\n        self.type = self.set_type(arg_type)\n        self.pgroup = self.get_parser_group()\n        self.multiple = False\n\n    def __eq__(self, arg):\n        \"\"\"\n        Compare to Argument object and say if they are equal.\n\n        :param arg: (Argument object)\n        \"\"\"\n        return (\n            self.name == arg.name\n            and self.default == arg.default\n            and self.help == arg.help\n            and self.short_name == arg.short_name\n            and self.value == arg.value\n            and self.is_flag == arg.is_flag\n            and self.const == arg.const\n            and self.type == arg.type\n            and self.pgroup == arg.pgroup\n        )\n\n    def get_type(self):\n        \"\"\"\n\n        :return:(type) the type of self\n        \"\"\"\n        if isinstance(self.type, type):\n            return self.type\n        else:\n            return type(self.type)\n\n    def set_type(self, arg_type):\n        \"\"\"\n        Set the type of self argument.\n\n        :param arg_type: (type or class instance) a type\n        :return: (type) the type of the argument\n        \"\"\"\n        if arg_type == inspect._empty:\n            return inspect._empty\n        if handled_type(arg_type):\n            if arg_type is bool or arg_type is click.BOOL:\n                if self.default == inspect._empty:\n                    self.default = False\n                elif self.default:\n                    self.default = False\n                    message(\"Default value set to False\", self, \"w\")\n                self.is_flag = True\n            check_subtype(arg_type, self)\n            return arg_type\n        if isinstance(arg_type, type):\n            msg = \"Not handled type %s\" % arg_type.__name__\n        else:\n            msg = \"unknown type %s\" % str(arg_type)\n        message(msg, self, \"e\")\n        exit(1)\n\n    def gfn(self):\n        \"\"\"\n        Get the full name of the argument.\n\n        :return: (string) the full name of the argument\n        \"\"\"\n        if self.short_name:\n            n = (\n                \"'[bold cyan]--%s[/bold cyan]' \"\n                + \"/ '[bold green]-%s[/bold green]'\"\n            )\n            name_arg = n % (\n                self.name,\n                self.short_name,\n            )\n        else:\n            name_arg = \"'[bold cyan]--%s[/bold cyan]'\" % self.name\n        return name_arg\n\n    def click_type(self):\n        \"\"\"\n        :return: (type)\n        \"\"\"\n        if self.type is bool:\n            return click.BOOL\n        elif isinstance(self.type, types.GenericAlias):\n            if self.type.__name__ == \"tuple\" and len(self.type.__args__) == 1:\n                return click.Tuple(self.type.__args__)\n            elif (\n                self.type.__name__ == \"tuple\"\n                and self.type.__args__[1] is not Ellipsis\n            ):\n                return click.Tuple(self.type.__args__)\n            else:\n                self.multiple = True\n                return self.type.__args__[0]\n        else:\n            return self.type\n\n    def click_narg(self):\n        if not isinstance(self.type, types.GenericAlias):\n            return None\n        elif self.type.__name__ == \"tuple\" and len(self.type.__args__) == 1:\n            return 1\n        elif (\n            self.type.__name__ == \"tuple\"\n            and self.type.__args__[1] is not Ellipsis\n        ):\n            return len(self.type.__args__)\n        else:\n            return 1\n\n    def get_parser_group(self) -&gt; str:\n        \"\"\"\n        Get the group name of the wanted argument.\n\n        :return: the name of the group\n        \"\"\"\n        for key in GROUPS.keys():\n            if self.name in GROUPS[key]:\n                if \"help\" in GROUPS[key]:\n                    return key\n                else:\n                    return key\n        if self.default == inspect._empty:\n            return REQUIRED_TITLE\n        else:\n            return OPTIONAL_TITLE\n</code></pre>"},{"location":"reference.html#lazyparser.Argument.__eq__","title":"<code>__eq__(arg)</code>","text":"<p>Compare to Argument object and say if they are equal.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <p>(Argument object)</p> required Source code in <code>lazyparser.py</code> <pre><code>def __eq__(self, arg):\n    \"\"\"\n    Compare to Argument object and say if they are equal.\n\n    :param arg: (Argument object)\n    \"\"\"\n    return (\n        self.name == arg.name\n        and self.default == arg.default\n        and self.help == arg.help\n        and self.short_name == arg.short_name\n        and self.value == arg.value\n        and self.is_flag == arg.is_flag\n        and self.const == arg.const\n        and self.type == arg.type\n        and self.pgroup == arg.pgroup\n    )\n</code></pre>"},{"location":"reference.html#lazyparser.Argument.__init__","title":"<code>__init__(name_arg, default, arg_type)</code>","text":"<p>Initiate the creation of an argument.</p> <p>Parameters:</p> Name Type Description Default <code>name_arg</code> <p>(string) the name of the argument</p> required <code>default</code> <p>the default value of the argument</p> required <code>arg_type</code> <p>(type) the type of the argument</p> required Source code in <code>lazyparser.py</code> <pre><code>def __init__(self, name_arg, default, arg_type):\n    \"\"\"\n    Initiate the creation of an argument.\n\n    :param name_arg: (string) the name of the argument\n    :param default: the default value of the argument\n    :param arg_type: (type) the type of the argument\n    \"\"\"\n    self.name = name_arg\n    self.default = default\n    self.help = \"param %s\" % self.name\n    self.short_name: str | None = None\n    self.value = None\n    self.is_flag = False\n    self.const = \"$$void$$\"\n    self.type = self.set_type(arg_type)\n    self.pgroup = self.get_parser_group()\n    self.multiple = False\n</code></pre>"},{"location":"reference.html#lazyparser.Argument.click_type","title":"<code>click_type()</code>","text":"<p>Returns:</p> Type Description <p>(type)</p> Source code in <code>lazyparser.py</code> <pre><code>def click_type(self):\n    \"\"\"\n    :return: (type)\n    \"\"\"\n    if self.type is bool:\n        return click.BOOL\n    elif isinstance(self.type, types.GenericAlias):\n        if self.type.__name__ == \"tuple\" and len(self.type.__args__) == 1:\n            return click.Tuple(self.type.__args__)\n        elif (\n            self.type.__name__ == \"tuple\"\n            and self.type.__args__[1] is not Ellipsis\n        ):\n            return click.Tuple(self.type.__args__)\n        else:\n            self.multiple = True\n            return self.type.__args__[0]\n    else:\n        return self.type\n</code></pre>"},{"location":"reference.html#lazyparser.Argument.get_parser_group","title":"<code>get_parser_group()</code>","text":"<p>Get the group name of the wanted argument.</p> <p>Returns:</p> Type Description <code>str</code> <p>the name of the group</p> Source code in <code>lazyparser.py</code> <pre><code>def get_parser_group(self) -&gt; str:\n    \"\"\"\n    Get the group name of the wanted argument.\n\n    :return: the name of the group\n    \"\"\"\n    for key in GROUPS.keys():\n        if self.name in GROUPS[key]:\n            if \"help\" in GROUPS[key]:\n                return key\n            else:\n                return key\n    if self.default == inspect._empty:\n        return REQUIRED_TITLE\n    else:\n        return OPTIONAL_TITLE\n</code></pre>"},{"location":"reference.html#lazyparser.Argument.get_type","title":"<code>get_type()</code>","text":"<p>Returns:</p> Type Description <p>(type) the type of self</p> Source code in <code>lazyparser.py</code> <pre><code>def get_type(self):\n    \"\"\"\n\n    :return:(type) the type of self\n    \"\"\"\n    if isinstance(self.type, type):\n        return self.type\n    else:\n        return type(self.type)\n</code></pre>"},{"location":"reference.html#lazyparser.Argument.gfn","title":"<code>gfn()</code>","text":"<p>Get the full name of the argument.</p> <p>Returns:</p> Type Description <p>(string) the full name of the argument</p> Source code in <code>lazyparser.py</code> <pre><code>def gfn(self):\n    \"\"\"\n    Get the full name of the argument.\n\n    :return: (string) the full name of the argument\n    \"\"\"\n    if self.short_name:\n        n = (\n            \"'[bold cyan]--%s[/bold cyan]' \"\n            + \"/ '[bold green]-%s[/bold green]'\"\n        )\n        name_arg = n % (\n            self.name,\n            self.short_name,\n        )\n    else:\n        name_arg = \"'[bold cyan]--%s[/bold cyan]'\" % self.name\n    return name_arg\n</code></pre>"},{"location":"reference.html#lazyparser.Argument.set_type","title":"<code>set_type(arg_type)</code>","text":"<p>Set the type of self argument.</p> <p>Parameters:</p> Name Type Description Default <code>arg_type</code> <p>(type or class instance) a type</p> required <p>Returns:</p> Type Description <p>(type) the type of the argument</p> Source code in <code>lazyparser.py</code> <pre><code>def set_type(self, arg_type):\n    \"\"\"\n    Set the type of self argument.\n\n    :param arg_type: (type or class instance) a type\n    :return: (type) the type of the argument\n    \"\"\"\n    if arg_type == inspect._empty:\n        return inspect._empty\n    if handled_type(arg_type):\n        if arg_type is bool or arg_type is click.BOOL:\n            if self.default == inspect._empty:\n                self.default = False\n            elif self.default:\n                self.default = False\n                message(\"Default value set to False\", self, \"w\")\n            self.is_flag = True\n        check_subtype(arg_type, self)\n        return arg_type\n    if isinstance(arg_type, type):\n        msg = \"Not handled type %s\" % arg_type.__name__\n    else:\n        msg = \"unknown type %s\" % str(arg_type)\n    message(msg, self, \"e\")\n    exit(1)\n</code></pre>"},{"location":"reference.html#lazyparser.HelpfulCmd","title":"<code>HelpfulCmd</code>","text":"<p>               Bases: <code>RichCommand</code></p> Source code in <code>lazyparser.py</code> <pre><code>class HelpfulCmd(click.RichCommand):\n    def collect_usage_pieces(self, ctx):\n        \"\"\"Returns all the pieces that go into the usage line and returns\n        it as a list of strings.\n        \"\"\"\n        rv = []\n        nt = \"\"\n        for p in self.params:\n            if p.required:\n                rv.append(f\"[bold cyan]--{p.name}[/bold cyan]\")\n                rv.append(f\"[bold yellow]{p.make_metavar()}[/bold yellow]\")\n            elif p.name not in FORBIDDEN:\n                if p.is_flag:  # type: ignore\n                    nt += f\"[--[bold cyan]{p.name}[/bold cyan]] \"\n                else:\n                    nt += f\"[--[bold cyan]{p.name}[/bold cyan] [bold yellow]{str(p.make_metavar())}[/bold yellow]] \"\n        rv.append(nt.strip())\n        return rv\n\n    def format_options(\n        self, ctx: click.Context, formatter: click.HelpFormatter\n    ) -&gt; None:\n        from rich_click.rich_help_rendering import get_rich_options\n\n        get_rich_options(self, ctx, formatter)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference.html#lazyparser.HelpfulCmd.collect_usage_pieces","title":"<code>collect_usage_pieces(ctx)</code>","text":"<p>Returns all the pieces that go into the usage line and returns it as a list of strings.</p> Source code in <code>lazyparser.py</code> <pre><code>def collect_usage_pieces(self, ctx):\n    \"\"\"Returns all the pieces that go into the usage line and returns\n    it as a list of strings.\n    \"\"\"\n    rv = []\n    nt = \"\"\n    for p in self.params:\n        if p.required:\n            rv.append(f\"[bold cyan]--{p.name}[/bold cyan]\")\n            rv.append(f\"[bold yellow]{p.make_metavar()}[/bold yellow]\")\n        elif p.name not in FORBIDDEN:\n            if p.is_flag:  # type: ignore\n                nt += f\"[--[bold cyan]{p.name}[/bold cyan]] \"\n            else:\n                nt += f\"[--[bold cyan]{p.name}[/bold cyan] [bold yellow]{str(p.make_metavar())}[/bold yellow]] \"\n    rv.append(nt.strip())\n    return rv\n</code></pre>"},{"location":"reference.html#lazyparser.Lazyparser","title":"<code>Lazyparser</code>","text":"<p>               Bases: <code>object</code></p> <p>Lazyparser class.</p> Source code in <code>lazyparser.py</code> <pre><code>class Lazyparser(object):\n    \"\"\"\n    Lazyparser class.\n    \"\"\"\n\n    def __init__(self, function, click_type):\n        \"\"\"\n        Initialization with a function.\n\n        :param function: (function) a function\n        :param click_type: (dictionary) the click dtype\n        \"\"\"\n        self.func = function\n        self.args = self.init_args()\n        self.help = self.description()\n        self.update_param()\n        self.get_short_name()\n        self.set_constrain(click_type)\n\n    def __eq__(self, parser):\n        \"\"\"\n        Compare to parser and say if they are the same. \\\n        Note that the functions defining the two Lazyparser object \\\n        can be different but if those function have the same signature \\\n        this function will return True as they will store the same arguments.\n\n        :param parser: (Lazyparser object)\n        :return: (bool)\n        \"\"\"\n        return self.args == parser.args and self.help == parser.help\n\n    def init_args(self):\n        \"\"\"\n        Initiate the creation the argument of interest.\n        \"\"\"\n        sign = inspect.signature(self.func).parameters\n        if any([x in sign.keys() for x in FORBIDDEN]):\n            bad = [x for x in FORBIDDEN if x in sign.keys()]\n            msg = (\n                f\"argument conflict, {bad} argument(s) cannot be set in\"\n                + \" the parsed function\"\n            )\n            message(msg, None, \"e\")\n            exit(1)\n        else:\n            dic_args = {\n                k: Argument(\n                    k,\n                    sign[k].default,\n                    sign[k].annotation\n                    if sign[k].annotation != inspect._empty\n                    else str,\n                )\n                for k in sign.keys()\n            }\n            tmp = {\"help\": Argument(\"help\", \"help\", str)}\n            if PROG_VERSION:\n                tmp[\"version\"] = Argument(\"version\", \"version\", str)\n            return tmp | dic_args\n\n    def description(self):\n        \"\"\"\n        Get the description of self.function.\n\n        :return: (string) description of self.func\n        \"\"\"\n        if not self.func.__doc__:\n            return \"\"\n        else:\n            description = \"\"\n            doc = iter(re.split(\"[\\n\\r]\", self.func.__doc__))\n            doc = itertools.dropwhile(lambda x: x == \"\", doc)\n            if PD1 == \"\":\n                delim = PD2\n            else:\n                delim = PD1\n            if not HEADER:\n                doc = itertools.takewhile(lambda x: delim not in x, doc)\n            else:\n                doc = itertools.takewhile(\n                    lambda x: delim not in x and HEADER not in x, doc\n                )\n            for line in doc:\n                if line[0:TAB].strip() == \"\":\n                    line = line[TAB:]\n                else:\n                    line = line.lstrip()\n                if description:\n                    description += \"\\n\" + line\n                else:\n                    description = line\n            return description\n\n    def get_short_name(self):\n        \"\"\"\n        Get the short param name of self.args\n        \"\"\"\n        param_names = sorted(list(self.args.keys()))\n        if \"help\" in param_names:\n            self.args[\"help\"].short_name = \"h\"\n            selected_param = [\"h\"]\n            del param_names[param_names.index(\"help\")]\n        else:\n            selected_param = []\n        for param in param_names:\n            sn = get_name(param, selected_param)\n            self.args[param].short_name = sn\n            selected_param.append(sn)\n\n    def set_constrain(self, click_type: dict[str, Any]):\n        \"\"\"\n        Set the contains for every param in self.args.\n\n        :param click_type: (dictionary of values) the constrains as click type\n        \"\"\"\n        for marg in click_type.keys():\n            if marg in self.args.keys():\n                if is_click_type(click_type[marg]):\n                    if (\n                        (\n                            isinstance(click_type[marg], click.IntRange)\n                            and self.args[marg].type is not int\n                        )\n                        or (\n                            isinstance(click_type[marg], click.FloatRange)\n                            and self.args[marg].type is not float\n                        )\n                        or (\n                            isinstance(click_type[marg], click.Choice)\n                            and self.args[marg].type is not str\n                        )\n                    ):\n                        message(\n                            f\"click type {click_type[marg]} incompatible \"\n                            + f\"with {self.args[marg].type}, \"\n                            + \"click type will be applied\",\n                            self.args[marg],\n                            \"w\",\n                        )\n                    self.args[marg].type = click_type[marg]\n                else:\n                    message(\n                        f\"Unknown click type {click_type[marg]}\",\n                        self.args[marg],\n                        \"e\",\n                    )\n                    exit(1)\n\n    def create_click_group(self):\n        \"\"\"\n        Create a click group for the parser.\n        \"\"\"\n        if GROUPS:\n            dic_grp = {k: [] for k in GROUPS}\n        else:\n            dic_grp = {}\n        for _, arg in self.args.items():\n            if arg.pgroup in dic_grp:\n                dic_grp[arg.pgroup].append(f\"--{arg.name}\")\n            else:\n                dic_grp[arg.pgroup] = [f\"--{arg.name}\"]\n        click.rich_click.OPTION_GROUPS = {\n            sys.argv[0]: [\n                {\"name\": key, \"options\": dic_grp[key]} for key in dic_grp\n            ]\n        }\n\n    def update_param(self):\n        \"\"\"\n        Update if needed the help of every args.\n        \"\"\"\n        if self.func.__doc__:\n            doc = filter(\n                lambda x: PD1 in x and PD2 in x,\n                re.split(\"[\\n\\r]\", self.func.__doc__),\n            )\n            for line in doc:\n                if PD1 != \"\":\n                    flt = list(filter(None, line.split(PD1)[1].split(PD2)))\n                else:\n                    flt = list(filter(None, line.split(PD2)))\n                flt = [word for word in flt]\n                flt[0] = flt[0].strip()\n                if flt[0] in self.args.keys():\n                    if len(flt[1:]) &gt; 1:\n                        flt_desc = PD2.join(flt[1:])\n                    else:\n                        flt_desc = flt[1]\n                    self.args[flt[0]].help = re.sub(\n                        \" +\", \" \", flt_desc.strip()\n                    )\n</code></pre>"},{"location":"reference.html#lazyparser.Lazyparser.__eq__","title":"<code>__eq__(parser)</code>","text":"<p>Compare to parser and say if they are the same.         Note that the functions defining the two Lazyparser object         can be different but if those function have the same signature         this function will return True as they will store the same arguments.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <p>(Lazyparser object)</p> required <p>Returns:</p> Type Description <p>(bool)</p> Source code in <code>lazyparser.py</code> <pre><code>def __eq__(self, parser):\n    \"\"\"\n    Compare to parser and say if they are the same. \\\n    Note that the functions defining the two Lazyparser object \\\n    can be different but if those function have the same signature \\\n    this function will return True as they will store the same arguments.\n\n    :param parser: (Lazyparser object)\n    :return: (bool)\n    \"\"\"\n    return self.args == parser.args and self.help == parser.help\n</code></pre>"},{"location":"reference.html#lazyparser.Lazyparser.__init__","title":"<code>__init__(function, click_type)</code>","text":"<p>Initialization with a function.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <p>(function) a function</p> required <code>click_type</code> <p>(dictionary) the click dtype</p> required Source code in <code>lazyparser.py</code> <pre><code>def __init__(self, function, click_type):\n    \"\"\"\n    Initialization with a function.\n\n    :param function: (function) a function\n    :param click_type: (dictionary) the click dtype\n    \"\"\"\n    self.func = function\n    self.args = self.init_args()\n    self.help = self.description()\n    self.update_param()\n    self.get_short_name()\n    self.set_constrain(click_type)\n</code></pre>"},{"location":"reference.html#lazyparser.Lazyparser.create_click_group","title":"<code>create_click_group()</code>","text":"<p>Create a click group for the parser.</p> Source code in <code>lazyparser.py</code> <pre><code>def create_click_group(self):\n    \"\"\"\n    Create a click group for the parser.\n    \"\"\"\n    if GROUPS:\n        dic_grp = {k: [] for k in GROUPS}\n    else:\n        dic_grp = {}\n    for _, arg in self.args.items():\n        if arg.pgroup in dic_grp:\n            dic_grp[arg.pgroup].append(f\"--{arg.name}\")\n        else:\n            dic_grp[arg.pgroup] = [f\"--{arg.name}\"]\n    click.rich_click.OPTION_GROUPS = {\n        sys.argv[0]: [\n            {\"name\": key, \"options\": dic_grp[key]} for key in dic_grp\n        ]\n    }\n</code></pre>"},{"location":"reference.html#lazyparser.Lazyparser.description","title":"<code>description()</code>","text":"<p>Get the description of self.function.</p> <p>Returns:</p> Type Description <p>(string) description of self.func</p> Source code in <code>lazyparser.py</code> <pre><code>def description(self):\n    \"\"\"\n    Get the description of self.function.\n\n    :return: (string) description of self.func\n    \"\"\"\n    if not self.func.__doc__:\n        return \"\"\n    else:\n        description = \"\"\n        doc = iter(re.split(\"[\\n\\r]\", self.func.__doc__))\n        doc = itertools.dropwhile(lambda x: x == \"\", doc)\n        if PD1 == \"\":\n            delim = PD2\n        else:\n            delim = PD1\n        if not HEADER:\n            doc = itertools.takewhile(lambda x: delim not in x, doc)\n        else:\n            doc = itertools.takewhile(\n                lambda x: delim not in x and HEADER not in x, doc\n            )\n        for line in doc:\n            if line[0:TAB].strip() == \"\":\n                line = line[TAB:]\n            else:\n                line = line.lstrip()\n            if description:\n                description += \"\\n\" + line\n            else:\n                description = line\n        return description\n</code></pre>"},{"location":"reference.html#lazyparser.Lazyparser.get_short_name","title":"<code>get_short_name()</code>","text":"<p>Get the short param name of self.args</p> Source code in <code>lazyparser.py</code> <pre><code>def get_short_name(self):\n    \"\"\"\n    Get the short param name of self.args\n    \"\"\"\n    param_names = sorted(list(self.args.keys()))\n    if \"help\" in param_names:\n        self.args[\"help\"].short_name = \"h\"\n        selected_param = [\"h\"]\n        del param_names[param_names.index(\"help\")]\n    else:\n        selected_param = []\n    for param in param_names:\n        sn = get_name(param, selected_param)\n        self.args[param].short_name = sn\n        selected_param.append(sn)\n</code></pre>"},{"location":"reference.html#lazyparser.Lazyparser.init_args","title":"<code>init_args()</code>","text":"<p>Initiate the creation the argument of interest.</p> Source code in <code>lazyparser.py</code> <pre><code>def init_args(self):\n    \"\"\"\n    Initiate the creation the argument of interest.\n    \"\"\"\n    sign = inspect.signature(self.func).parameters\n    if any([x in sign.keys() for x in FORBIDDEN]):\n        bad = [x for x in FORBIDDEN if x in sign.keys()]\n        msg = (\n            f\"argument conflict, {bad} argument(s) cannot be set in\"\n            + \" the parsed function\"\n        )\n        message(msg, None, \"e\")\n        exit(1)\n    else:\n        dic_args = {\n            k: Argument(\n                k,\n                sign[k].default,\n                sign[k].annotation\n                if sign[k].annotation != inspect._empty\n                else str,\n            )\n            for k in sign.keys()\n        }\n        tmp = {\"help\": Argument(\"help\", \"help\", str)}\n        if PROG_VERSION:\n            tmp[\"version\"] = Argument(\"version\", \"version\", str)\n        return tmp | dic_args\n</code></pre>"},{"location":"reference.html#lazyparser.Lazyparser.set_constrain","title":"<code>set_constrain(click_type)</code>","text":"<p>Set the contains for every param in self.args.</p> <p>Parameters:</p> Name Type Description Default <code>click_type</code> <code>dict[str, Any]</code> <p>(dictionary of values) the constrains as click type</p> required Source code in <code>lazyparser.py</code> <pre><code>def set_constrain(self, click_type: dict[str, Any]):\n    \"\"\"\n    Set the contains for every param in self.args.\n\n    :param click_type: (dictionary of values) the constrains as click type\n    \"\"\"\n    for marg in click_type.keys():\n        if marg in self.args.keys():\n            if is_click_type(click_type[marg]):\n                if (\n                    (\n                        isinstance(click_type[marg], click.IntRange)\n                        and self.args[marg].type is not int\n                    )\n                    or (\n                        isinstance(click_type[marg], click.FloatRange)\n                        and self.args[marg].type is not float\n                    )\n                    or (\n                        isinstance(click_type[marg], click.Choice)\n                        and self.args[marg].type is not str\n                    )\n                ):\n                    message(\n                        f\"click type {click_type[marg]} incompatible \"\n                        + f\"with {self.args[marg].type}, \"\n                        + \"click type will be applied\",\n                        self.args[marg],\n                        \"w\",\n                    )\n                self.args[marg].type = click_type[marg]\n            else:\n                message(\n                    f\"Unknown click type {click_type[marg]}\",\n                    self.args[marg],\n                    \"e\",\n                )\n                exit(1)\n</code></pre>"},{"location":"reference.html#lazyparser.Lazyparser.update_param","title":"<code>update_param()</code>","text":"<p>Update if needed the help of every args.</p> Source code in <code>lazyparser.py</code> <pre><code>def update_param(self):\n    \"\"\"\n    Update if needed the help of every args.\n    \"\"\"\n    if self.func.__doc__:\n        doc = filter(\n            lambda x: PD1 in x and PD2 in x,\n            re.split(\"[\\n\\r]\", self.func.__doc__),\n        )\n        for line in doc:\n            if PD1 != \"\":\n                flt = list(filter(None, line.split(PD1)[1].split(PD2)))\n            else:\n                flt = list(filter(None, line.split(PD2)))\n            flt = [word for word in flt]\n            flt[0] = flt[0].strip()\n            if flt[0] in self.args.keys():\n                if len(flt[1:]) &gt; 1:\n                    flt_desc = PD2.join(flt[1:])\n                else:\n                    flt_desc = flt[1]\n                self.args[flt[0]].help = re.sub(\n                    \" +\", \" \", flt_desc.strip()\n                )\n</code></pre>"},{"location":"reference.html#lazyparser.add_option","title":"<code>add_option(option, func)</code>","text":"<p>Add an option to the function used to create the CLI.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Argument</code> <p>a lazyparser argument</p> required <code>func</code> <code>Callable</code> <p>the function used to create a CLI</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The function func decorated with click.option()</p> Source code in <code>lazyparser.py</code> <pre><code>def add_option(option: Argument, func: Callable) -&gt; Callable:\n    \"\"\"\n    Add an option to the function used to create the CLI.\n\n    :param option: a lazyparser argument\n    :param func: the function used to create a CLI\n    :return: The function func decorated with click.option()\n    \"\"\"\n    args = (f\"--{option.name}\", f\"-{option.short_name}\")\n    kwargs = dict(\n        nargs=option.click_narg(),\n        type=option.click_type(),\n        is_flag=option.is_flag,\n        show_default=False,\n        required=True,\n        help=option.help,\n        multiple=option.multiple,\n    )\n    if option.default != inspect._empty:\n        kwargs[\"default\"] = option.default\n        kwargs[\"required\"] = False\n        kwargs[\"show_default\"] = True\n    func = click.option(\n        *args,\n        **kwargs,  # type: ignore\n    )(func)\n\n    return func\n</code></pre>"},{"location":"reference.html#lazyparser.check_subtype","title":"<code>check_subtype(argtype, arg)</code>","text":"<p>check if the subtype is supported.</p> <p>Parameters:</p> Name Type Description Default <code>argtype</code> <code>type | GenericAlias</code> <p>a type or list object</p> required <code>arg</code> <code>Argument</code> <p>an Argument</p> required Source code in <code>lazyparser.py</code> <pre><code>def check_subtype(argtype: type | types.GenericAlias, arg: Argument):\n    \"\"\"\n    check if the subtype is supported.\n\n    :param argtype: a type or list object\n    :param arg: an Argument\n    \"\"\"\n    if isinstance(argtype, types.GenericAlias):\n        if not all(handled_type(t, \"s\") for t in argtype.__args__):\n            message(\n                \"unknown %s subtype of %s\"\n                % (argtype.__args__, argtype.__name__),\n                arg,\n                \"e\",\n            )\n            exit(1)\n        for i, t in enumerate(argtype.__args__):\n            if t is Ellipsis and i != 1:\n                message(\n                    \"Ellipsis is allowed as the second of two arguments\",\n                    arg,\n                    \"e\",\n                )\n</code></pre>"},{"location":"reference.html#lazyparser.docstrings","title":"<code>docstrings(**env)</code>","text":"<p>Function used to set a value to some parameters when they are called.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <p>(dictionary) the named arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[..., Callable[[], Any]]</code> <p>(function) wrap</p> Source code in <code>lazyparser.py</code> <pre><code>def docstrings(**env) -&gt; Callable[..., Callable[[], Any]]:\n    \"\"\"\n    Function used to set a value to some parameters when they are called.\n\n    :param env: (dictionary) the named arguments\n    :return: (function) wrap\n    \"\"\"\n\n    def wrap(function):\n        \"\"\"\n        Wrapper of the function ``function``.\n\n        :param function: (function) the function to wrap\n        :return: (function) the method calling `` function``.\n        \"\"\"\n\n        @functools.wraps(function)\n        def call_func():\n            \"\"\"\n            Call the function ``self.func`` and return it's result.\n\n            :return: the result of the function ``self.func``\n            \"\"\"\n            if env:\n                set_env(env)\n            return function()\n\n        return call_func\n\n    return wrap\n</code></pre>"},{"location":"reference.html#lazyparser.epilog","title":"<code>epilog(epilog=None)</code>","text":"<p>Function used to set a value to some parameters when they are called.</p> <p>Parameters:</p> Name Type Description Default <code>epilog</code> <code>str | None</code> <p>A string corresponding to the epilog of the help message</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Callable[[], Any]]</code> <p>(function) wrap</p> Source code in <code>lazyparser.py</code> <pre><code>def epilog(epilog: str | None = None) -&gt; Callable[..., Callable[[], Any]]:\n    \"\"\"\n    Function used to set a value to some parameters when they are called.\n\n    :param epilog: A string corresponding to the epilog of the help message\n    :return: (function) wrap\n    \"\"\"\n\n    def wrap(function):\n        \"\"\"\n        Wrapper of the function ``function``.\n\n        :param function: (function) the function to wrap\n        :return: (function) the method calling `` function``.\n        \"\"\"\n\n        @functools.wraps(function)\n        def call_func():\n            \"\"\"\n            Call the function ``self.func`` and return it's result.\n\n            :return: the result of the function ``self.func``\n            \"\"\"\n            if isinstance(epilog, str):\n                global EPI\n                EPI = epilog.strip()\n            elif epilog is not None:\n                message(\"epilog must be a string\", None, \"e\")\n            return function()\n\n        return call_func\n\n    return wrap\n</code></pre>"},{"location":"reference.html#lazyparser.get_name","title":"<code>get_name(name, list_of_name, size=1)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <p>(string) the param name</p> required <code>list_of_name</code> <p>(string) the list of param name</p> required <code>size</code> <p>(int) the size of the name used</p> <code>1</code> <p>Returns:</p> Type Description <p>(string) the param name selected</p> Source code in <code>lazyparser.py</code> <pre><code>def get_name(name, list_of_name, size=1):\n    \"\"\"\n\n    :param name: (string) the param name\n    :param list_of_name: (string) the list of param name\n    :param size: (int) the size of the name used\n    :return: (string) the param name selected\n    \"\"\"\n    if size == len(name):\n        return name\n    elif name[0:size] not in list_of_name:\n        return name[0:size]\n    elif name[0:size].upper() not in list_of_name:\n        return name[0:size].upper()\n    else:\n        return get_name(name, list_of_name, size=size + 1)\n</code></pre>"},{"location":"reference.html#lazyparser.get_rich_usage","title":"<code>get_rich_usage(formatter, prog, args='', prefix=None)</code>","text":"<p>Richly render usage text.</p> Source code in <code>lazyparser.py</code> <pre><code>def get_rich_usage(\n    formatter: Any,\n    prog: str,\n    args: str = \"\",\n    prefix: str | None = None,\n) -&gt; None:\n    \"\"\"Richly render usage text.\"\"\"\n    if prefix is None:\n        prefix = \"Usage:\"\n\n    config = formatter.config\n\n    # Header text if we have it\n    if config.header_text:\n        formatter.write(\n            Padding(\n                _make_rich_rext(\n                    config.header_text, config.style_header_text, formatter\n                ),\n                (1, 1, 0, 1),\n            ),\n        )\n\n    # Print usage\n    formatter.write(\n        Padding(\n            Columns(\n                (\n                    Text(prefix, style=config.style_usage),\n                    Text(prog, style=config.style_usage_command),\n                    args,\n                )\n            ),\n            1,\n        ),\n    )\n</code></pre>"},{"location":"reference.html#lazyparser.groups","title":"<code>groups(**groups)</code>","text":"<p>Function used to set a value to some parameters when they are called.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <p>the groups of options to create</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[..., Callable[[], Any]]</code> <p>(function) wrap</p> Source code in <code>lazyparser.py</code> <pre><code>def groups(**groups) -&gt; Callable[..., Callable[[], Any]]:\n    \"\"\"\n    Function used to set a value to some parameters when they are called.\n\n    :param groups: the groups of options to create\n    :return: (function) wrap\n    \"\"\"\n\n    def wrap(function):\n        \"\"\"\n        Wrapper of the function ``function``.\n\n        :param function: (function) the function to wrap\n        :return: (function) the method calling `` function``.\n        \"\"\"\n\n        @functools.wraps(function)\n        def call_func():\n            \"\"\"\n            Call the function ``self.func`` and return it's result.\n\n            :return: the result of the function ``self.func``\n            \"\"\"\n            if groups is not None:\n                set_groups(groups)\n            return function()\n\n        return call_func\n\n    return wrap\n</code></pre>"},{"location":"reference.html#lazyparser.handled_type","title":"<code>handled_type(atype, htype='m')</code>","text":"<p>Get the type of an argument.</p> <p>Parameters:</p> Name Type Description Default <code>atype</code> <p>(type) a type</p> required <code>htype</code> <p>(str) m for subtype and s for subtype</p> <code>'m'</code> <p>Returns:</p> Type Description <p>(type) the type of an argument</p> Source code in <code>lazyparser.py</code> <pre><code>def handled_type(atype, htype=\"m\"):\n    \"\"\"\n    Get the type of an argument.\n\n    :param atype: (type) a type\n    :param htype: (str) m for subtype and s for subtype\n    :return: (type) the type of an argument\n    \"\"\"\n    dic_type = {\n        \"m\": [int, float, bool, str, tuple],\n        \"s\": [int, float, str, Ellipsis],\n    }\n    if isinstance(atype, types.GenericAlias):\n        atype = atype.__mro__[0]\n    if atype in dic_type[htype]:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference.html#lazyparser.init_parser","title":"<code>init_parser(lp, func)</code>","text":"<p>Create the parser using click.</p> <p>Parameters:</p> Name Type Description Default <code>lp</code> <code>Lazyparser</code> <p>the parsed arguments</p> required <code>func</code> <code>Callable</code> <p>the function used to create a CLI</p> required <p>Returns:</p> Type Description <p>The function func decorated with click.option()</p> Source code in <code>lazyparser.py</code> <pre><code>def init_parser(lp: Lazyparser, func: Callable):\n    \"\"\"\n    Create the parser using click.\n\n    :param lp: the parsed arguments\n    :param func: the function used to create a CLI\n    :return: The function func decorated with click.option()\n    \"\"\"\n    func.__doc__ = lp.description()\n    for arg in lp.args:\n        if arg not in FORBIDDEN:\n            func = add_option(lp.args[arg], func)\n    lp.create_click_group()\n    if PROG_VERSION:\n        func = click.version_option(PROG_VERSION)(func)\n    func = click.help_option(\"-h\", \"--help\")(func)\n    if STD_MODE:\n        func = click.command(cls=HelpfulCmd, epilog=EPI)(func)\n    else:\n        func = click.command(cls=HelpfulCmd, epilog=EPI)(func).main(\n            standalone_mode=False\n        )\n    return func\n</code></pre>"},{"location":"reference.html#lazyparser.is_click_type","title":"<code>is_click_type(atype)</code>","text":"<p>Check if the atype is a click type.</p> <p>Parameters:</p> Name Type Description Default <code>atype</code> <p>(type) a type</p> required <p>Returns:</p> Type Description <p>(bool) True if the type is a click type, False otherwise</p> Source code in <code>lazyparser.py</code> <pre><code>def is_click_type(atype):\n    \"\"\"\n    Check if the atype is a click type.\n\n    :param atype: (type) a type\n    :return: (bool) True if the type is a click type, False otherwise\n    \"\"\"\n    try:\n        res = issubclass(atype, click.Path.__mro__[1])\n        if res:\n            return True\n    except TypeError:\n        res = issubclass(type(atype), click.Path.__mro__[1])\n        if res:\n            return True\n    return False\n</code></pre>"},{"location":"reference.html#lazyparser.message","title":"<code>message(sentence, argument, type_m=None)</code>","text":"<p>Return a message in the correct format.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>str</code> <p>(string) the message we want to return.</p> required <code>argument</code> <code>Argument | None</code> <p>(Argument object) a Lazyparser argument.</p> required <code>type_m</code> <code>str | None</code> <p>(string or None) the type of the message to display</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>(string) the message in a correct format.</p> Source code in <code>lazyparser.py</code> <pre><code>def message(\n    sentence: str, argument: Argument | None, type_m: str | None = None\n) -&gt; None:\n    \"\"\"\n    Return a message in the correct format.\n\n    :param sentence: (string) the message we want to return.\n    :param argument: (Argument object) a Lazyparser argument.\n    :param type_m: (string or None) the type of the message to display\n    :return: (string) the message in a correct format.\n    \"\"\"\n    sentence = re.sub(r\"\\s+\", \" \", sentence)\n    if argument is not None:\n        sentence = argument.gfn() + \" \" + sentence\n    if type_m not in [\"w\", \"e\"]:\n        rprint(sentence)\n    elif type_m == \"w\":\n        rprint(\n            Panel(\n                sentence,\n                title=\"Warning\",\n                border_style=\"orange3\",\n                title_align=\"left\",\n            )\n        )\n    else:\n        rprint(\n            Panel(\n                sentence, title=\"Error\", border_style=\"red\", title_align=\"left\"\n            )\n        )\n        exit(1)\n</code></pre>"},{"location":"reference.html#lazyparser.parse","title":"<code>parse(func=None, **click_types)</code>","text":"<p>Create the parser.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable | None</code> <p>(function) the function of interest</p> <code>None</code> <code>click_types</code> <p>(dictionary) the click types</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[..., Callable[[], Any]]</code> <p>(function) wrap</p> Source code in <code>lazyparser.py</code> <pre><code>def parse(\n    func: Callable | None = None,\n    **click_types,\n) -&gt; Callable[..., Callable[[], Any]]:\n    \"\"\"\n    Create the parser.\n\n    :param func: (function) the function of interest\n    :param click_types: (dictionary) the click types\n    :return: (function) wrap\n    \"\"\"\n\n    def wrap(function: Callable) -&gt; Callable[[], Any]:\n        \"\"\"\n        Wrapper of the function ``function``.\n\n        :param function: (function) the function to wrap\n        :return: (function) the method calling `` function``.\n        \"\"\"\n\n        @functools.wraps(function)\n        def call_func(*args, **kw):\n            \"\"\"\n            Call the function ``self.func`` and return it's result.\n\n            :return: the result of the function ``self.func``\n            \"\"\"\n            lazyparser = Lazyparser(function, click_types)\n            func = init_parser(lazyparser, function)\n            if STD_MODE:\n                return func(*args, **kw)\n            else:\n                return func\n\n        return call_func\n\n    if func is None:\n        return wrap\n    return wrap(func)\n</code></pre>"},{"location":"reference.html#lazyparser.set_env","title":"<code>set_env(env)</code>","text":"<p>Change the param delimiters.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>dict | None</code> <p>A dictionnary that may contain the following keys: - tab: (int) the number of spaces or tabs before the docstring - delim1: (str) the first delimiter of a parameter - delim2: (str) the second delimiter of a parameter - header: (str) the parameters header</p> required Source code in <code>lazyparser.py</code> <pre><code>def set_env(env: dict | None):\n    \"\"\"\n    Change the param delimiters.\n\n    :param env: A dictionnary that may contain the following keys:\n        - tab: (int) the number of spaces or tabs before the docstring\n        - delim1: (str) the first delimiter of a parameter\n        - delim2: (str) the second delimiter of a parameter\n        - header: (str) the parameters header\n    \"\"\"\n    if not env:\n        return None\n    for v, t in zip(\n        [\"tab\", \"delim1\", \"delim2\", \"header\", \"epilog\"],\n        [int, str, str, str, str],\n    ):\n        if v in env and not isinstance(env[v], t):\n            message(f\"{v} must be of type {t.__name__}\", None, \"e\")\n    if \"tab\" in env and isinstance(env[\"tab\"], int):\n        global TAB\n        TAB = env[\"tab\"]\n    if \"delim1\" in env and isinstance(env[\"delim1\"], str):\n        global PD1\n        PD1 = env[\"delim1\"].strip()\n    if \"delim2\" in env and isinstance(env[\"delim2\"], str):\n        if env[\"delim2\"].strip() == \"\":\n            message(\"delim2 cannot be empty\", None, \"e\")\n        global PD2\n        PD2 = env[\"delim2\"].strip()\n    if \"header\" in env and isinstance(env[\"header\"], str):\n        global HEADER\n        HEADER = env[\"header\"].strip()\n</code></pre>"},{"location":"reference.html#lazyparser.set_groups","title":"<code>set_groups(arg_groups=None)</code>","text":"<p>Change the name of the argument groups.</p> <p>Parameters:</p> Name Type Description Default <code>arg_groups</code> <p>(dictionary of list of string) links each arguments to     its groups.</p> <code>None</code> Source code in <code>lazyparser.py</code> <pre><code>def set_groups(arg_groups=None):\n    \"\"\"\n    Change the name of the argument groups.\n\n    :param arg_groups: (dictionary of list of string) links each arguments to \\\n    its groups.\n    \"\"\"\n    pname = {}\n    tmp = []\n    help_name = \"Optional arguments\"\n    if arg_groups:\n        for key in arg_groups.keys():\n            if \"help\" in arg_groups[key]:\n                help_name = key\n                n = \"__parser__\"\n            else:\n                n = \"\".join(re.findall(r\"[A-Za-z0-9_]\", key))\n                n = re.sub(r\"^[0-9]*\", \"\", n)\n                if len(n) == 0:\n                    msg = (\n                        \"The name '%s' must have at least one of the\"\n                        + \"following symbols [A-Za-z]\"\n                    ) % key\n                    message(msg, None, \"e\")\n                    exit(1)\n            pname[key] = n\n            if n not in tmp:\n                tmp.append(n)\n            else:\n                msg = (\n                    \"%s after removing symbols not in [A-Za-z0-9]\"\n                    + \"is already defined\"\n                ) % key\n                message(msg, None, \"e\")\n                exit(1)\n    global GROUPS\n    GROUPS = arg_groups if arg_groups is not None else {}\n    global LPG_NAME\n    LPG_NAME = pname\n    global OPTIONAL_TITLE\n    OPTIONAL_TITLE = help_name\n</code></pre>"},{"location":"reference.html#lazyparser.standalone","title":"<code>standalone(mode=None)</code>","text":"<p>Function used to set a value to some parameters when they are called.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>bool | None</code> <p>Standalone mode to set</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Callable[[], Any]]</code> <p>(function) wrap</p> Source code in <code>lazyparser.py</code> <pre><code>def standalone(mode: bool | None = None) -&gt; Callable[..., Callable[[], Any]]:\n    \"\"\"\n    Function used to set a value to some parameters when they are called.\n\n    :param mode: Standalone mode to set\n    :return: (function) wrap\n    \"\"\"\n\n    def wrap(function):\n        \"\"\"\n        Wrapper of the function ``function``.\n\n        :param function: (function) the function to wrap\n        :return: (function) the method calling `` function``.\n        \"\"\"\n\n        @functools.wraps(function)\n        def call_func():\n            \"\"\"\n            Call the function ``self.func`` and return it's result.\n\n            :return: the result of the function ``self.func``\n            \"\"\"\n            if isinstance(mode, bool):\n                global STD_MODE\n                STD_MODE = mode\n            return function()\n\n        return call_func\n\n    return wrap\n</code></pre>"},{"location":"reference.html#lazyparser.version","title":"<code>version(version=None)</code>","text":"<p>Function used to set a value to some parameters when they are called.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str | None</code> <p>the version of the program where the decorated function is called</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Callable[[], Any]]</code> <p>(function) wrap</p> Source code in <code>lazyparser.py</code> <pre><code>def version(version: str | None = None) -&gt; Callable[..., Callable[[], Any]]:\n    \"\"\"\n    Function used to set a value to some parameters when they are called.\n\n    :param version: the version of the program where\n    the decorated function is called\n    :return: (function) wrap\n    \"\"\"\n\n    def wrap(function):\n        \"\"\"\n        Wrapper of the function ``function``.\n\n        :param function: (function) the function to wrap\n        :return: (function) the method calling `` function``.\n        \"\"\"\n\n        @functools.wraps(function)\n        def call_func():\n            \"\"\"\n            Call the function ``self.func`` and return it's result.\n\n            :return: the result of the function ``self.func``\n            \"\"\"\n            if version is not None:\n                if not isinstance(version, str):\n                    message(\"version must be a string\", None, \"e\")\n                global PROG_VERSION\n                PROG_VERSION = version.strip()\n                FORBIDDEN.append(\"version\")\n            return function()\n\n        return call_func\n\n    return wrap\n</code></pre>"}]}